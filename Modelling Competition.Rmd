---
title: "Modelling Competition: House Prices"
author: 
- Roberto Alvarez Llordachs
- Javier Goñi Artieda
- Marcos Crespo Díaz
- Gabriela Levenfeld Sabau
- Sofía Gianelli Nan
- Miguel Díaz-Plaza Cabrera
date: "`r Sys.Date()`"
output:
  pdf_document: 
    toc: yes
    toc_depth: 4
    number_sections: yes
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,warning=FALSE, message=FALSE, cache=TRUE)
```

# Introduction

House prices have sparked lot of debate recently in our society. Currently, this topic has aroused controversy on the grounds that has been a cornerstone in 2008 crisis. Were buyers to decide a model for setting the selling price, which factors would be included and what would be their weight?

The goal of this project is to create a effective price prediction model.

# Libraries

```{r, message=FALSE, warning=FALSE}
library(skimr)
library(dplyr)
library(tidyverse)
library(caret)
library(plotly)
library(data.table)
library(GGally)
library(tidymodels)
library(car)
library(scales)
library(MASS)
library(lmtest)
```

# Data Preparation

First step would be to load both databases, train and test.

```{r}
train <- read.csv("train.csv", sep=",")
test <- read.csv("test.csv", sep=",")

column_diff <- setdiff(names(train), names(test))
```

We are going to work with the target variable (SalePrice) in log

```{r}
train$SalePrice<-log(train$SalePrice)
```

## We make EDA (Exploratory Data Analysis) of the train set

We are only going to work with the train set due to the test set is for studying the accuracy of the model.

```{r}
skim(train) 
#Presents results for every column; the statistics it provides depend on the class of the variable
```



```{r}
# Ordenar las columnas por tipo de variable (Las 25 primeras son continuas)
train <- train[,c(1,81,4,5,20,21,27,35,37,38,39,44,45,46,47,60,63,67,68,69,70,71,72,76,78,48,49,50,51,52,53,55,57,62,77,2,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,22,23,24,25,26,28,29,30,31,32,33,34,36,40,41,42,43,54,56,58,59,61,64,65,66,73,74,75,79,80)]

#test <- test[,c(1,4,5,20,21,27,35,37,38,39,44,45,46,47,60,63,67,68,69,70,71,72,76,78,2,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,22,23,24,25,26,28,29,30,31,32,33,34,36,40,41,42,43,48,49,50,51,52,53,54,55,56,57,58,59,61,62,64,65,66,73,74,75,77,79,80)]
```



```{r}
# Eliminate the ID columns
train <- train[,-1]
test <- test[,-1]
```

## Missing value problem:

Looking at the dataset, we observe that some of the variables have great deal of NA values. Therefore, it may interesting to quantify these numbers and later think on future actions.

```{r}
# Counting NA: TRAIN and express in %
Number_NA<-(colSums(is.na(train))/nrow(train))*100
sort(Number_NA,decreasing = TRUE)
```

```{r}
# Counting NA: TEST y expresado en %
#(colSums(is.na(test))/nrow(train))*100
```

What should we then do this those variables that have more missing values than existing ones? Maintaining them can we a problem as makes no sense to substitute missing values with an statistic of the remaining, such as the mean, as the latter would not be representative. 
However, NA values have a meaning in most of the cases where its percentage is high. For example, in PoolQC it means that the house does not have pool, in Alley means that the house no alley access. Consequently, we should change NA for values so that they will later appear when displaying these variables values. 

```{r}
train$PoolQC <- ifelse(is.na(train$PoolQC),"None",train$PoolQC)
train$Fence <- ifelse(is.na(train$Fence),"None",train$Fence)
train$Alley <- ifelse(is.na(train$Alley),"None",train$Alley)
train$BsmtFinType1 <- ifelse(is.na(train$BsmtFinType1),"None",train$BsmtFinType1)
train$BsmtCond <- ifelse(is.na(train$BsmtCond),"None",train$BsmtCond)
train$BsmtQual <- ifelse(is.na(train$BsmtQual),"None",train$BsmtQual)
train$BsmtFinType2 <- ifelse(is.na(train$BsmtFinType2),"None",train$BsmtFinType2)
train$BsmtExposure <- ifelse(is.na(train$BsmtExposure),"None",train$BsmtExposure)
train$FireplaceQu <- ifelse(is.na(train$FireplaceQu),"None",train$FireplaceQu)
train$GarageCond <- ifelse(is.na(train$GarageCond),"None",train$GarageCond)
train$GarageQual <- ifelse(is.na(train$GarageQual),"None",train$GarageQual)
train$GarageFinish <- ifelse(is.na(train$GarageFinish),"None",train$GarageFinish)
train$GarageType <- ifelse(is.na(train$GarageType),"None",train$GarageType)
train$MiscFeature <- ifelse(is.na(train$MiscFeature),"None",train$MiscFeature)
train$MasVnrType <- ifelse(is.na(train$MasVnrType),"None",train$MasVnrType)
```
```{r garage}
train$GarageArea<- ifelse(train$GarageArea==0,NA,train$GarageArea)
train$GarageCars<- ifelse(train$GarageCars==0,NA,train$GarageCars)
```
```{r garage}
train$MasVnrArea<-ifelse(train$MasVnrArea==0,NA,train$MasVnrArea)
```
There are 5 variables that have NA´s and they lack of meaning, for integer ones (LotFrontage, GarageYrBlt and MasVnrArea) we will replace NA for the mean rounded, whereas for the categorical ones (Electrical and MasVnrType), as the percentage of NA is quite small (<1%) we will replace for the mode. 

```{r}
train$LotFrontage <- ifelse(is.na(train$LotFrontage),round(mean(train$LotFrontage,na.rm=TRUE)),train$LotFrontage)
train$Electrical <- ifelse(is.na(train$Electrical),"SBrkr",train$Electrical) #Imputation with the mode for only 1 observation
```
```{r frontage}
# Calcular la mediana por grupo utilizando tapply
medianas_por_grupo <- tapply(train$LotFrontage, train$Neighborhood, FUN = function(x) median(x, na.rm = TRUE))

# Sustituir NA por la mediana correspondiente por grupo
train$LotFrontage <- ifelse(is.na(train$LotFrontage), medianas_por_grupo[as.character(train$Neighborhood)],train$LotFrontage )

```
*CORREGIR*

*MEDIANAS POR GRUPO ESTÁ BIEN. HAY QUE TERMINAR EL CODIGO QUE LO SUSTITUYA*

**HAY QUE HACER EL DUMMY DE SI TIENE GARAGE, masvnr**

```{r duplicates}
sum(duplicated(train))
```


##Handle categorical variables:

Next, the goal is to modify categorical variables as a factor so as to work with them.
```{r}
train <- train %>% mutate_if(~is.character(.), ~as.factor(.))
#Nonetheless not all categorical variables are character defined, we modify using factor those who aren´t
train$OverallQual <- factor(train$OverallQual)
train$OverallCond <- factor(train$OverallCond)
train$MSSubClass <- factor(train$MSSubClass)

sort(sapply(train,class))
```

**CON OVERALL's NO SABEMOS AUN SI TRATAR COMO NUMERICA O COMO CATEGORICA**

## Numeric data handling (outliers and scaling):

Once we have categorical variables in order, we should focus our attention on quantitative data. 
```{r}
#We extract a dataset only with quantitative data (34 variables)
num_train_dataset <- train %>% select_if(is.numeric)
```

We will focus first on the outliers, observations that are far away from the regression line (*Meter sino una def y aprovechar para bibliografía*). They do not affect the estimated model, unless the observation has high leverage. It tends to increase the variability among the variable affecting the negatively the variability explained by the model, making it become worse. 
Comparing the maximum values and the means of some of the variables we suspect the existance of outliers due to the huge differences between them. 
```{r}
summary(num_train_dataset)

outlier <- num_train_dataset %>% filter(PoolArea >= 50)
outlier <- num_train_dataset %>% filter(LotArea >= 150000)

library(base)
#cooks.distance() #Creo que no nos sirve, probar con esto: https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/influence.measures

#Para el scaling alguien que entienda que mire los graficos de abajo. Yo creo que alguna hay que hacer log.
```

# Exploratory Analysis

In the first part, we will carry out a descriptive analysis of several variables to understand them better. Graphs will help us to reach this goal, histograms for continuous variables and box-plots for categorical variables.

It would be useful to analyse the categorical variables, seeing most popular categories for each variables.

```{r}
# Lista de columnas categóricas
columnas_categoricas <- colnames(train)[sapply(train, is.factor)]
columnas_categoricas

tablas_frecuencia <- list()

#INTENTO 1
# Iterar sobre cada columna categórica y crear la tabla de frecuencia
for (col in columnas_categoricas) {
  tablas_frecuencia[[col]] <- table(train[[col]])
}

# Mostrar las tablas de frecuencia
tablas_frecuencia
```

**HACER BOXPLOTS DE LAS QUE VAYAMOS A EXPLICAR**

```{r}
par(mfrow = c(3, 4))
colours <- c("red", "blue", "green",
             "orange", "purple", "pink",
             "brown", "gray", "cyan", "magenta", "darkgreen", "lightblue")

for (i in 2:13) {
  col_name <- colnames(num_train_dataset)[i]
  boxplot(num_train_dataset[, i], 
       main = col_name,
       xlab = "Values", 
       col = colours[i - 1], 
       breaks = 5)
}
```
```{r}
par(mfrow = c(3, 4))
colours <- c("red", "blue", "green",
             "orange", "purple", "pink",
             "brown", "gray", "cyan", "magenta", "darkgreen","lightblue")

for (i in 14:25) {
  col_name <- colnames(num_train_dataset)[i]
  boxplot(num_train_dataset[, i], 
       main = col_name,
       xlab = "Values", 
       col = colours[i - 13],
       breaks = 5)
}
```
```{r}
par(mfrow = c(3, 4))
colours <- c("red", "blue", "green",
             "orange", "purple", "pink",
             "brown", "gray", "cyan")

for (i in 26:34) {
  col_name <- colnames(num_train_dataset)[i]
  boxplot(num_train_dataset[, i], 
       main = col_name,
       xlab = "Values", 
       col = colours[i - 25],
       breaks = 5)
}
```

```{r}
par(mfrow = c(3, 4))
colours <- c("red", "blue", "green",
             "orange", "purple", "pink",
             "brown", "gray", "cyan", "magenta", "darkgreen", "lightblue")

for (i in 2:13) {
  col_name <- colnames(num_train_dataset)[i]
  hist(num_train_dataset[, i], 
       main = col_name,
       xlab = "Values", 
       col = colours[i - 1], 
       breaks = 5)
}
```

```{r}
par(mfrow = c(3, 4))
colours <- c("red", "blue", "green",
             "orange", "purple", "pink",
             "brown", "gray", "cyan", "magenta", "darkgreen","lightblue")

for (i in 14:25) {
  col_name <- colnames(num_train_dataset)[i]
  hist(num_train_dataset[, i], 
       main = col_name,
       xlab = "Values", 
       col = colours[i - 13],
       breaks = 5)
}
```

```{r}
par(mfrow = c(3, 4))
colours <- c("red", "blue", "green",
             "orange", "purple", "pink",
             "brown", "gray", "cyan")

for (i in 26:34) {
  col_name <- colnames(num_train_dataset)[i]
  hist(num_train_dataset[, i], 
       main = col_name,
       xlab = "Values", 
       col = colours[i - 25],
       breaks = 5)
}
```


Moreover, summary statistics are a useful tool for analyzing continuous variables (*YA VISTO ARRIBA*).

```{r}
measures <- function(x){
  c(mean(x), median(x), mode(x), var(x), sd(x), skew(x), kurtosi(x))
}
```


##Correlation:
To see which the quantitative features that strongly affect home price, checking the correlation may be an interesting idea.

```{r, fig.height=7,fig.width=7}
correlation_matrix <- cor(num_train_dataset)
rownames(correlation_matrix) <- colnames(correlation_matrix) <- 1:ncol(correlation_matrix)
corrplot(correlation_matrix, method = "color", tl.col = "black", title="Correlation Matrix",tl.srt = 0,tl.cex = 0.7)
#No consigo que cuadren los axis con los puntos que representan
#Correlacion nula con 8,13,20,22,23,24,26 y 34
#Baja con 3,9,21,25,28,29,19 y 30(ULTIMOS CASOS ES -)
#Media con 2,6,7,12,17,18,
#Alta con 4,5,10,11,14,16,27,33 (32,15)

#high_correlation_values <- correlation_matrix[correlation_matrix > 0.7]
#print(high_correlation_values)
high_correlation_indices <- which(correlation_matrix > 0.7, arr.ind = TRUE)

# Muestra los pares de variables que cumplen con la condición
for (i in 1:nrow(high_correlation_indices)) {
  row_index <- high_correlation_indices[i, 1]
  col_index <- high_correlation_indices[i, 2]
  var1 <- colnames(correlation_matrix)[row_index]
  var2 <- colnames(correlation_matrix)[col_index]
  cat("Correlation between", var1, "and", var2, ":", correlation_matrix[row_index, col_index], "\n")
}

print(high_correlation_indices)
#Este código se me ha quedado a medias
```

The only variable that are negatively correlated with house price are EnclosedPorch and KitchenAbvGr, but as the correlation of both is quite small we will not worry to much. 
The variables that are highly correlated are:
-YearBuild:
-YearRemodAdd:
-TotalBsmtSF:
-X1stFloorSF:
-GrLivArea:
-GarageArea:
-FullBath:
-GarageCars:

(Fireplaces, GarageYrBuild)

Nonetheless, correlation has other important use, help to find multicollinearity among variables.


How to deal with multicolinearity?: (*Slides*)
-Ignore it
-Use antoher estimator other than Least Square
-Get rid of these redundant variables using variable selection techniques.

##ANOVA:


#Model:
##Variable selection:
Tema 3
Ideas en base a Lab1:

- Data preprocessing: Remove unnecesary columns such as ID, in Lab1 remove characteristics with one observation. Check that categorical variables are factors. Check summary to check everything is correct.

- After datapreprocessing do Exploratory analysis: Correlations (ggpairs, in Lab 2 values and colors), histograms of predictors, plots of response vs some predictors (only comment important ones)

- Modeling: regsubsets only when continuous, Lab1 use stepAIC... Check model assumptions.

- Prediction

##Codigo extra que creo que se puede eliminar:

```{r}
# Lista de variables categóricas
variables_categoricas <- c("MSSubClass", "MSZoning", "Street", "Alley", "LotShape", "LandContour",
                            "Utilities", "LotConfig", "LandSlope", "Neighborhood", "Condition1",
                            "Condition2", "BldgType", "HouseStyle", "OverallQual", "OverallCond",
                            "RoofStyle", "RoofMatl", "Exterior1st", "Exterior2nd", "MasVnrType",
                            "ExterQual", "ExterCond", "Foundation", "BsmtQual", "BsmtCond",
                            "BsmtExposure", "BsmtFinType1", "BsmtFinType2", "Heating", "HeatingQC",
                            "CentralAir", "Electrical", "KitchenQual", "Functional", "FireplaceQu",
                            "GarageType", "GarageFinish", "GarageQual", "GarageCond", "PavedDrive",
                            "PoolQC", "Fence", "MiscFeature", "SaleType", "SaleCondition")

# Función para obtener el conteo de observaciones para cada variable categórica
obtener_conteo <- function(df, var) {
  conteo <- df %>% count({{ var }})
  print(conteo)
}

# Obtener el conteo de observaciones para cada variable categórica
for (variable in variables_categoricas) {
  obtener_conteo(train, !!as.name(variable))
}
```

```{r}
umbral <- 2 # Definir el umbral mínimo de instancias

# Lista de columnas categóricas
columnas_categoricas <- colnames(train)[sapply(train, is.factor)]

# Iterar sobre cada columna categórica y conservar las categorías con más de 'umbral' instancias
for (col in columnas_categoricas) {
  filtro <- train %>% count(!!sym(col)) %>% filter(n > umbral)
  train <- train[train[[col]] %in% filtro[[col]], ]
  train[[col]] <- factor(train[[col]], levels = unique(train[[col]]))
}

# Mostrar las categorías conservadas en cada columna categórica
for (col in columnas_categoricas) {
  cat(paste("Columna:", col, "\n"))
  print(table(train[[col]]))
}
```

```{r}
#Esta es otra alternativa pero peor
plot1 <-
  ggplot(train, aes(LotFrontage)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Linear feet of street connected to property")
plot2 <-
  ggplot(train, aes(LotArea)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Lot size in square feet ")
plot3 <-
  ggplot(train, aes(YearBuilt)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Original construction date")
plot4 <-
  ggplot(train, aes(YearRemodAdd)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Remodel date")
plot5 <-
  ggplot(train, aes(MasVnrArea)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Masonry veneer area")
plot6 <-
  ggplot(train, aes(BsmtFinSF1)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Type 1 finished square feet")
plot7 <-
  ggplot(train, aes(BsmtFinSF2)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Type 2 finished square feet")
plot8 <-
  ggplot(train, aes(BsmtUnfSF)) + geom_histogram(fill = "lightblue",  bins = 10) + labs(title ="Unfinished sq feet of basement area")
plot9 <-
  ggplot(train, aes(TotalBsmtSF)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Total sq feet of basement area")
plot10 <-
  ggplot(train, aes(X1stFlrSF)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="1st Floor sq feet")
plot11 <-
  ggplot(train, aes(X2ndFlrSF)) + geom_histogram(fill = "lightblue",  bins = 10) + labs(title ="2nd floor sq feet ")
plot12 <-
  ggplot(train, aes(LowQualFinSF)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Low quality finished sq feet")
plot13 <-
  ggplot(train, aes(GrLivArea)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Above grade living area sq feet")
plot14 <-
  ggplot(train, aes(GarageYrBlt)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Year garage was built")
plot15 <-
  ggplot(train, aes(GarageArea)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Size of garage in sq feet ")
plot16 <-
  ggplot(train, aes(WoodDeckSF)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Wood deck area in sq feet ")
plot17 <-
  ggplot(train, aes(OpenPorchSF)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Open porch area in sq feet")
plot18 <-
  ggplot(train, aes(EnclosedPorch)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Enclosed porch area in sq feet")
plot19 <-
  ggplot(train, aes(X3SsnPorch)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="3 season porch area in sq feet")
plot20 <-
  ggplot(train, aes(ScreenPorch)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Screen porch area in sq feet")
plot21 <-
  ggplot(train, aes(PoolArea)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Pool area in sq feet")
plot22 <-
  ggplot(train, aes(MiscVal)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="$Value of miscellaneous feature")
plot23 <-
  ggplot(train, aes(YrSold)) + geom_histogram(fill = "lightblue", bins = 10) + labs(title ="Year Sold")

grid.arrange(
  plot1,
  plot2,
  plot3,
  plot4,
  plot5,
  plot6,
  plot7,
  plot8,
  plot9,
  plot10,
  plot11,
  plot12,
  plot13,
  plot14,
  plot15,
  plot16,
  plot17,
  plot18,
  plot19,
  plot20,
  plot21,
  plot22,
  plot23,
  ncol = 3,
  top = "Histograms"
)
```


